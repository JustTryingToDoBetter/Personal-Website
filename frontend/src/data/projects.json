[
  {
    "id": 1,
    "title": "Football Player Tracking System",
    "tagline": "Advanced real-time player detection and tracking using state-of-the-art computer vision",
    "year": "2025",
    "status": "Completed",
    "category": "Computer Vision",
    "tech": ["YOLOv8", "DeepSORT", "ByteTrack", "Python", "OpenCV", "PyTorch"],
    "description": "Comparative analysis of player tracking algorithms in football footage using YOLOv8 for detection and MOT metrics for evaluation.",
    "problem": "Traditional player tracking in football relies on expensive hardware and manual annotation. Coaches and analysts need an affordable, accurate system to analyze player movement, positioning, and performance metrics in real-time from regular video footage.",
    "solution": "I developed a computer vision pipeline that leverages YOLOv8 for player detection and compares multiple tracking algorithms (DeepSORT and ByteTrack). The system processes video frames at 30+ FPS, assigns unique IDs to players, and generates heatmaps and movement analytics. Custom training on football-specific datasets improved accuracy to 95%.",
    "image": "/assets/projects/tracking.jpg",
    "github": "https://github.com/JustTryingToDoBetter/football-tracking",
    "liveDemo": "",
    "planetType": "rocky",
    "stats": [
      { "value": "95%", "label": "Detection Accuracy" },
      { "value": "30+", "label": "FPS Processing" },
      { "value": "5K+", "label": "Frames Analyzed" },
      { "value": "22", "label": "Players Tracked" }
    ],
    "features": [
      {
        "title": "Real-Time Detection",
        "description": "YOLOv8-powered player detection with 95% accuracy on live video streams"
      },
      {
        "title": "Multi-Object Tracking",
        "description": "Persistent ID assignment across frames using DeepSORT and ByteTrack"
      },
      {
        "title": "Movement Analytics",
        "description": "Heatmaps, distance covered, speed analysis, and positioning metrics"
      },
      {
        "title": "Comparative Analysis",
        "description": "Side-by-side evaluation of tracking algorithms using MOT metrics"
      },
      {
        "title": "Video Export",
        "description": "Annotated video output with bounding boxes, IDs, and trajectories"
      },
      {
        "title": "Custom Training",
        "description": "Fine-tuned model on football-specific datasets for improved performance"
      }
    ],
    "techStack": [
      {
        "name": "Computer Vision",
        "items": [
          { "name": "YOLOv8", "version": "8.0.196" },
          { "name": "OpenCV", "version": "4.8.0" },
          { "name": "PyTorch", "version": "2.0.1" }
        ]
      },
      {
        "name": "Tracking",
        "items": [
          { "name": "DeepSORT", "version": "latest" },
          { "name": "ByteTrack", "version": "latest" }
        ]
      },
      {
        "name": "Processing",
        "items": [
          { "name": "NumPy", "version": "1.24.3" },
          { "name": "Pandas", "version": "2.0.3" },
          { "name": "Matplotlib", "version": "3.7.2" }
        ]
      }
    ],
    "architecture": {
      "description": "The system uses a pipeline architecture: video input → frame extraction → YOLOv8 detection → tracking algorithm (DeepSORT/ByteTrack) → analytics generation → visualization output. Each component is modular and can be swapped independently."
    },
    "codeSnippets": [
      {
        "title": "YOLOv8 Detection Pipeline",
        "language": "Python",
        "code": "def detect_players(frame, model):\n    results = model.predict(frame, conf=0.4, classes=[0])\n    detections = []\n    \n    for box in results[0].boxes:\n        x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()\n        conf = float(box.conf[0])\n        detections.append({\n            'bbox': [x1, y1, x2 - x1, y2 - y1],\n            'confidence': conf\n        })\n    \n    return detections"
      },
      {
        "title": "Tracking with DeepSORT",
        "language": "Python",
        "code": "def track_players(detections, tracker):\n    tracker.predict()\n    tracker.update(detections)\n    \n    tracked_objects = []\n    for track in tracker.tracks:\n        if not track.is_confirmed():\n            continue\n        \n        bbox = track.to_tlbr()\n        tracked_objects.append({\n            'id': track.track_id,\n            'bbox': bbox,\n            'state': track.state\n        })\n    \n    return tracked_objects"
      }
    ],
    "results": [
      "Achieved 95% detection accuracy on test footage, surpassing the 85% baseline",
      "Successfully tracked 22 players simultaneously across 5000+ frames",
      "Processed video at 30+ FPS on consumer-grade GPU (RTX 3060)",
      "Generated actionable insights: heatmaps, distance covered, average speed",
      "ByteTrack outperformed DeepSORT by 8% in maintaining ID consistency",
      "Received interest from local football coaches for deployment"
    ],
    "lessons": [
      "Custom dataset training significantly improved accuracy over pre-trained models. Collecting and annotating domain-specific data (football footage) was time-consuming but essential.",
      "Balancing detection confidence thresholds is critical - too high misses players, too low creates false positives. Extensive testing helped find the sweet spot at 0.4.",
      "Real-time performance requires optimization at every stage. I learned to use batch processing, GPU acceleration, and efficient data structures.",
      "Different tracking algorithms excel in different scenarios. DeepSORT is robust with occlusions, while ByteTrack handles fast movements better."
    ],
    "screenshots": [
      {
        "url": "/assets/projects/tracking-demo.jpg",
        "caption": "Player detection and tracking in action with bounding boxes and IDs"
      },
      {
        "url": "/assets/projects/tracking-heatmap.jpg",
        "caption": "Heatmap visualization showing player positioning and movement patterns"
      }
    ],
    "timeline": [
      { "title": "Research & Planning", "date": "Jan 2025" },
      { "title": "Dataset Collection", "date": "Feb 2025" },
      { "title": "Model Training", "date": "Mar 2025" },
      { "title": "Tracking Integration", "date": "Apr 2025" },
      { "title": "Testing & Optimization", "date": "May 2025" },
      { "title": "Deployment", "date": "Jun 2025" }
    ],
    "team": [
      { "name": "Jaydin Morrison", "role": "Lead Developer & ML Engineer" }
    ]
  },
  {
    "id": 2,
    "title": "Analytics Server",
    "tagline": "High-performance real-time analytics engine for live events",
    "year": "2025",
    "status": "In Production",
    "category": "Backend Development",
    "tech": ["FastAPI", "Redis", "PostgreSQL", "Docker", "Celery"],
    "description": "Real-time leaderboard and analytics engine for live event data, built with distributed caching and queueing.",
    "problem": "Live events generate massive amounts of data that need instant processing and display. Traditional databases struggle with the write-heavy workload and can't deliver sub-second response times for leaderboards and analytics.",
    "solution": "Built a high-performance analytics server using FastAPI for the API layer, Redis for caching and real-time updates, PostgreSQL for persistent storage, and Celery for background tasks. The architecture handles 10,000+ requests per second with sub-100ms response times.",
    "image": "/assets/projects/analytics.jpg",
    "github": "https://github.com/JustTryingToDoBetter/analytics-server",
    "liveDemo": "",
    "planetType": "oceanic",
    "stats": [
      { "value": "10K+", "label": "Requests/Second" },
      { "value": "<100ms", "label": "Response Time" },
      { "value": "99.9%", "label": "Uptime" },
      { "value": "5M+", "label": "Events Processed" }
    ],
    "features": [
      {
        "title": "Real-Time Leaderboards",
        "description": "Live rankings updated instantly with Redis sorted sets"
      },
      {
        "title": "Event Stream Processing",
        "description": "Handle thousands of concurrent events with async processing"
      },
      {
        "title": "Distributed Caching",
        "description": "Multi-layer caching strategy for optimal performance"
      },
      {
        "title": "Background Jobs",
        "description": "Celery workers for heavy analytics computations"
      },
      {
        "title": "WebSocket Updates",
        "description": "Push real-time updates to connected clients"
      },
      {
        "title": "API Rate Limiting",
        "description": "Protect server from abuse with intelligent rate limiting"
      }
    ],
    "techStack": [
      {
        "name": "API",
        "items": [
          { "name": "FastAPI", "version": "0.104.1" },
          { "name": "Pydantic", "version": "2.4.2" },
          { "name": "Uvicorn", "version": "0.24.0" }
        ]
      },
      {
        "name": "Data Layer",
        "items": [
          { "name": "Redis", "version": "7.2" },
          { "name": "PostgreSQL", "version": "15.0" },
          { "name": "SQLAlchemy", "version": "2.0.23" }
        ]
      },
      {
        "name": "Background Tasks",
        "items": [
          { "name": "Celery", "version": "5.3.4" },
          { "name": "RabbitMQ", "version": "3.12" }
        ]
      },
      {
        "name": "DevOps",
        "items": [
          { "name": "Docker", "version": "24.0" },
          { "name": "Docker Compose", "version": "2.23" },
          { "name": "Nginx", "version": "1.25" }
        ]
      }
    ],
    "results": [
      "Successfully handles 10,000+ requests per second during peak events",
      "Maintains <100ms average response time even under heavy load",
      "Achieved 99.9% uptime over 6 months of production use",
      "Processed over 5 million events with zero data loss",
      "Reduced infrastructure costs by 40% through efficient caching",
      "Currently powering 3 live production applications"
    ],
    "lessons": [
      "Redis is incredibly powerful for real-time data but requires careful memory management. I learned to implement TTL strategies and LRU eviction policies.",
      "Async Python (FastAPI) offers massive performance gains over synchronous frameworks. Understanding event loops and coroutines was crucial.",
      "Monitoring and observability are not optional. I integrated Prometheus and Grafana early, which saved countless hours of debugging.",
      "Database connection pooling and query optimization can make or break performance. I spent significant time tuning PostgreSQL for write-heavy workloads."
    ]
  },
  {
    "id": 3,
    "title": "Maski Playground",
    "year": "2024",
    "status": "Live",
    "category": "Creative Dev",
    "tech": ["Vue", "Node", "Tailwind", "Three.js"],
    "description": "An experimental cyberpunk-themed portfolio playground that merges code, art, and motion interaction.",
    "image": "/assets/projects/playground.jpg",
    "github": "https://github.com/JustTryingToDoBetter/maski-playground",
    "planetType": "gas-giant"
  },
  {
    "id": 4,
    "title": "File Server",
    "year": "2024",
    "tech": ["Flask", "Docker", "SQLite"],
    "description": "A minimalist drag-and-drop file upload and management interface with local API authentication.",
    "image": "/assets/projects/fileserver.jpg",
    "github": "https://github.com/JustTryingToDoBetter/file-server",
    "planetType": "desert"
  }
]
